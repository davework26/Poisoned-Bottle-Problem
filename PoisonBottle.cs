using System;
using System.Collections.Generic;
using System.Linq;

namespace PoisonBottle
{
    public class PoisonBottle
    {
        /// <summary>
        /// The number of bottles to be checked for poison.
        /// </summary>
        private const int MaxBottles = 1000;

        /// <summary>
        /// The number of prisoners to drink from the bottles.
        /// </summary>
        private const int MaxPrisoners = 10;

        /// <summary>
        /// The bottles to be tested, one of which will contain the value true and is the poisoned 
        /// bottle. All the remaining non-poisoned bottles contain default values of false.
        /// </summary>
        private bool[] _bottles = new bool[MaxBottles];

        /// <summary>
        /// An array of prisoners indexed by prisoner number: each entry is a list of bottles drank by 
        /// that prisoner.
        /// </summary>
        private List<int>[] _bottlesDrankByPrisoner = new List<int>[MaxPrisoners];

        /// <summary>
        /// Bitwise masks values as powers of 2 (starting at 2 to the power of zero = 1) 
        /// for each prisoner, indexed by prisoner number. 
        /// <example>
        /// 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 for prisoners 0-9 respectively.
        /// </example>
        /// These values will mask off all the bits of a bottle number except for the ones associated
        /// with the prisoner, to determine whether the prisoner drank from the bottle.
        /// It's also used in the reverse process, to determine the poisoned bottle from the dead 
        /// prisoners.
        /// </summary>
        private int[] _powersOf2Masks = new int[MaxPrisoners];

        /// <param name="poisonedBottle">poisoned bottle number in range 0 to MaxBottles-1</param>
        public PoisonBottle(int poisonedBottle)
        {
            if (poisonedBottle < 0 || poisonedBottle >= MaxBottles)
            {
                throw new ArgumentOutOfRangeException("poisonedBottle", poisonedBottle, 
                    string.Format("Must be between 0 and {0}", MaxBottles - 1));
            }
            _bottles[poisonedBottle] = true;
        }

        /// <summary>
        /// Generate logical bit masks for each prisoner, used in bottle drinking calculations.
        /// Each bit mask will be the value of 2 raised by the prisoner number, so only one bit
        /// in the mask will be set, the remainder will be unset.
        /// Powers of 2 can be generated by left bitwise shifting the value of 1 for each 
        /// successive power (prisoner).
        /// </summary>
        private void CalcPowersOf2Masks()
        {
            int powerOf2 = 1;

            for (int power = 0; power < MaxPrisoners; power++)
            {
                //_PowersOf2Masks[power] = (int)Math.Pow(2, power);
                _powersOf2Masks[power] = powerOf2;
                powerOf2 = powerOf2 << 1;
            }

        }

        /// <summary>
        /// For all bottles, generate a list of bottles drank by each prisoner.
        /// </summary>
        private void PrisonersDrinkBottles()
        {
            // Initialise prisoner bottle bitmasks.
            CalcPowersOf2Masks();
            for (int prisoner = 0; prisoner < MaxPrisoners; prisoner++)
            {
                _bottlesDrankByPrisoner[prisoner] = new List<int>();
                for (int bottle = 0; bottle < MaxBottles; bottle++)
                {
                    if (IsBottleDrankByPrisoner(bottle, prisoner)) {
                        // Record that bottle was drank by prisoner.
                        _bottlesDrankByPrisoner[prisoner].Add(bottle);
                    }
                }
            }
        }

        /// <summary>
        /// Determine if the prisoner should drink from the bottle.
        /// If any bits of the bottle number remain set after being masked off for the prisoner
        /// (i.e. a non-zero value) then the bottle is drank by that prisoner. If none of the bits
        /// remain set (i.e. a zero value) then the bottle is not drank by the prisoner.
        /// The prisoner's mask is held in _PowersOf2Masks and indexed by the prisoner number.
        /// </summary>
        /// <example>
        /// Bottle 3's binary value is 11 for bits 1 and 0, so prisoner 0 should drink from this bottle 
        /// because prisoner 0's mask value in _PowersOf2Masks[0] is 1 and 
        /// bitwise 1 &amp; 3, in binary is 00 &amp; 01 = 01 = 1 (i.e. non-zero = drink). 
        /// Similarly, prisoner 1 should drink from this bottle because prisoner 1's mask value 
        /// in _PowersOf2Masks[1] is 2 and bitwise 2 &amp; 3, in binary is 10 &amp; 11 = 10 = 2
        /// (i.e. non-zero which means drink).
        /// However, prisoner 2 should not drink from this bottle because prisoner 2's mask value
        /// in _PowersOf2Masks[2] is 4 and bitwise 4 &amp; 3, in binary is 100 &amp; 011 = 000 = 0
        /// (i.e. zero which means don't drink).
        /// </example>
        /// <param name="bottle">the bottle being drank</param>
        /// <param name="prisoner">the prisoner drinking from the bottle</param>
        /// <returns>true if bottle is drank by the prisoner, otherwise false</returns>
        private bool IsBottleDrankByPrisoner(int bottle, int prisoner)
        {
            int mask = _powersOf2Masks[prisoner];
            // Apply the prisoner's bit mask to the bottle number.
            int drank = mask & bottle;

            // Any bits remain set?
            return Convert.ToBoolean(drank);
        }

        /// <summary>
        /// Determine the poisoned bottle number by checking if each prisoner is dead.
        /// The poison bottle number is the sum of the dead prisoners' mask values.
        /// </summary>
        /// <example>If only prisoner 1 and 0 are alive, then the poison bottle number is the binary
        /// number where only bits 1 and 0 are set, i.e. 3. 
        /// This is the sum of (2 to power of 1) + (2 to the power of 0) = (2 + 1) = 3.
        /// 2 to the power of 0 is stored in _powersOf2Masks[0] = 1 and
        /// 2 to the power of 1 is stored in _powersOf2Masks[1] = 2, 
        /// and are indexed by prisoner number.
        /// </example>
        /// <returns>poisoned bottle number</returns>
        private int CalcPoisonedBottleFromDeadPrisoners()
        {
            int bottle = 0;

            for (int prisoner = 0; prisoner < MaxPrisoners; prisoner++)
            {
                if (!IsPrisonerAliveAfter24Hours(_bottlesDrankByPrisoner[prisoner])) {
                    bottle += _powersOf2Masks[prisoner];
                }
            }

            return bottle;
        }

        /// <summary>
        /// Determine if the poisoned bottle is in the list of bottles drank by the prisoner.
        /// </summary>
        /// <param name="bottlesDrank">List of the bottles drank by the prisoner</param>
        /// <returns>true if prisoner is alive and didn't drink from the poisonous bottle or
        /// false if they are dead and did drink from the poisonous bottle.</returns>
        private bool IsPrisonerAliveAfter24Hours(List<int> bottlesDrank)
        {
            for (int bottleDrank = 0; bottleDrank < bottlesDrank.Count; bottleDrank++)
            {
                // Is this bottle drank poisoned?
                if (_bottles[bottlesDrank[bottleDrank]])
                {
                    // Poisonous bottle drank so prisoner dies. No need test remaining bottles.
                    return false;
                }
            }

            // Prisoner lives.
            return true;
        }

        /// <summary>
        /// Solution to method 2 of 1000 bottle wine problem defined here:
        /// https://medium.com/i-math/a-king-1000-bottles-of-wine-10-prisoners-and-a-drop-of-poison-2dd1959a8dd2
        /// </summary>
        /// <returns>bottle number of poisoned bottle</returns>
        public int PoisonedBottle()
        {
            // Calculate which prisoners drank from each bottle.
            PrisonersDrinkBottles();

            // Calculate the poisoned bottle from the dead prisoners.
            int poisonedBottle = CalcPoisonedBottleFromDeadPrisoners();

            return poisonedBottle;
        }

        /// <summary>
        /// Test solution by poisoning each bottle in turn. 
        /// Prints 'true' if all tests pass or 'false' if a test fails. 
        /// </summary>
        /// <param name="args">Command line arguments. None needed.</param>
        static public void Main(string[] args)
        {
            bool passed = true;

            // Poison each bottle in turn.
            for (int poisonedBottle = 0; poisonedBottle < MaxBottles; poisonedBottle++)
            {
                // Poison the bottle.
                PoisonBottle poisonBottle = new PoisonBottle(poisonedBottle);
                if (poisonedBottle != poisonBottle.PoisonedBottle())
                {
                    // Test fails: calculated bottle number doesn't match test scenario.
                    passed = false;
                    break;
                }
            }
            Console.WriteLine("Tests passed: {0}", passed);
        }
    }
}
